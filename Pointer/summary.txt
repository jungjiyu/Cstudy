Call By Value 
	: 값만 전달한다. 원본 값에 영향을 주지 않는다 (지역 변수 값만 깔짝 바뀌겠지)
	: C 언어 해당 << 암기 : C Val 씨 발
	: https://programist.tistory.com/entry/C-%EC%96%B8%EC%96%B4-Call-by-Value%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C-Call-by-Reference%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C%EC%9D%98-%EC%9D%B4%ED%95%B4

	: Call By Reference 
		: 참조를 전달하는 방식. 원본 값이 바뀐다
		: C언어에서 공식적으로 지원하지 않지만 포인터로 흉내내는거다



-----------------------------------------------------------------------------------------------------------------------------------

<포인터>

포인터 = 다른변수의 메모리 주소를 저장하는 '변수'
	: 선언
		: 자료형 * 포인터명;
			: 선언할때 쓰이는 * 은 간접참조연산자가 아닌 그냥 일반적인 변수와 포인터 변수의 선언을 구분하기 위한 기호

			: 가리킬변수의자료형== 포인터명 앞에 간접참조연산자 하나만 남기고 남은 형태
				: 이 타입으로 포인터연산을 하게 된다.

			: 포인터의 자료형 == 포인터명 앞 전체부분
				ex) int **b ; // int * == 가리킬변수의 자료형 , int ** == 포인터의 자료형



	: 초기화 >> 변수의 주소나 동적할당결과의 주소값으로 초기화한다.
		:포인터는 반드시 초기화 한 이후에 활용가능하다.
			
		
	: 포인터의 크기 
		: 포인터들끼리 자료형이 다르더라도 포인터의 크기가 같다
			: 32비트 운영 체제 기준 4바이트, 64비트 운영 체제 기준 8바이트
			: 포인터들끼리 크기가 같은데도 가리킬변수의 자료형을 명시하며 선언하는 이유는 참조단위를 결정하기 위함이다.
				:그 단위로 해당 위치에서 값을 읽어오고, 그 단위로 포인터 연산을 하게 된다.		


	: 포인터 연산
		:주소가 정수값이긴 해도 일반적인 정수와 다르게 다루어진다.
		:주소 + 정수 == 주소 +  (정수*변수크기)
		: ex)
			int a = 10;
			int *p = &a; // &a ==0 일때
			printf("걍p: %d , p+1 = %d", p , (p+1));  //p == 0 이고 , p+1 == 4 이다




-----------------------------------------------------------------------------------------------------------------------------------
<다중포인터>

다중포인터: 포인터의 주소를 값으로 하는 변수
	:이중까지만 보통 쓴다. (삼중,사중... 도 가능)


	:선언형식
		자료형	**이중포인터명;
			: 일반적인 포인터는 자료형 * 포인터명; 선언
			뜻은 (자료형) *포인터명; 으로 (자료형)타입의 변수를 가리키는 포인터를 선언했다는거임.
			이중포인터의 뜻은 (자료형*) *이중포인터명 으로 (자료형*) 타입의 변수를 가리키는 포인터를 선언했다는 거임

			: 이중포인터의 자료형은 (자료형**) 취급하면됨
				:'선언시 변수 바로 앞 별하나' == 포인터선언관례 ,
				'선언시 변수 바로앞 별하나 제외 나머지 부분' ==  '가리키는 변수의 자료형' ,
				'포인터명 앞부분전체' == '포인터의 자료형'
	:초기화형식
		이중포인터명=&포인터명;
	: 헷갈정리
		: &주소 는 불가능해도 &포인터는 된다.
			: 포인터도 변수니까 저장되는 메모리가 있다
		:
		이중포인터명 == 단일포인터주소
		*이중포인터명 == 단일포인터값==단일포인터가참조하는변수주소
		**이중포인터명 == 변수값 == 단일포인터가참조하는변수의값

	:활용
		1. 포인터값을 바꿀때(포인터가 어떤 변수를 가리킬지를 바꿀때) 매개변수로 사용
			:다중포인터가 필요한게 단일포인터로는 포인터의값(가리킬주소값)을 변경하지 못하기 때문이다
			: 간접참조연산자를 써서 바꿔야 찐으로 블럭 외부에서도 바뀌는건데 단일로만은 불가하다.
				: 단일포인터 매개변수로는 변수값을 바꾸는게 최대이다
					: 블럭내부에서 다른 변수의 주소를 복사해봤자 그 포인터는 매개변수라서 밖에서 적용이 안된다.

			: 포인터자체의 주소를 변경하겠단얘기가 아니라 포인터가 어떤 변수를 가리킬지를 변경하겠단 말이다
			ex)
			void change(int *a,int *b){
				*a = 10; //해당주소의 변수값을 수정할 순 있다
				a=b;//소용이 없는게 블럭 내부에서 당장은 주소값이 복사될지라도 밖에선 복사된게 아니다. 블럭내부의 포인터값이 바뀐것일뿐. 참조연산자가 있어야 찐 수정된거임.
			}

			void change(int **a , int **b){
				**a =10; //해당주소의 변수값 수정도 가능
				*a=*b; //주소값을 전역스케일로 변경가능

			}
			ex) 이중포인터를 사용하여 문자열 2개 swap <-- 개천재인게 swap 에서 tmp 역할얘를 배열로 만들어서 strcpy한게 아니라 그냥 포인터형으로 선언햇서
			첫번째 요소의 주소만 가져와서 포인터의 주소값만 바꿔준것


		2. 포인터배열을 매개변수로 받는 함수
			배열명 == '0번째 요소의 주소' 이므로 배열명도 일종의 포인터라고 할 수 있다(변경이 불가한 것 뿐)
			따라서 포인터배열명 == '0번째 요소의 주소' == '포인터의주소' == '이중포인터명'


*/



<포인터와 배열>

배열과 포인터

	: '포인터명 == 배열명 == 배열의 0번째요소의 주소 '
	로 배열명과 포인터명 둘다 주소값이긴 해도 배열명은 상수이기에 변경이 불가하고
	포인터명은 주소를 저장하는 변수이기에 변경이 가능하다.
		:ex)
		int a[]={1,2,3};
		int *p=a;
		int i;

		for(i=0;i<3;i++){
		printf("%d",*(p++)); // p값은 변경됨
		}

		for(i=0;i<3;i++){
		printf("%d",*(a+i)); // a값은 유지됨
		}

	: (같은 자료형의) 포인터끼리 뺼셈도 가능하다
		: 포인터 - 포인터 == (두 포인터 주소값 차) / 자료형 크기 ==	몇 칸 이동하면 상대 포인터 위치로 가는지
			: a +2 == b 라고(a에서 2칸 더간게 b) 했을때 b-2 == a 되는거니까 (b에서 2칸 전으로 간게 a)

	: 배열을 인수로 받을떄 포인터를 매개변수로 하는 이유
		: 모든 요소를 넘기지 않아도 포인터 연산을 통하여 모든 요소에 접근이 가능하니까

	: 함수에서 인수로 배열을 받고 그 사이즈를 사용해야할 일이 있으면 매개변수 부분에서 사이즈를 따로 받아둔다
		: 아무리 포인터가 배열을 가리키는 경우라해도 sizeof 연산자를 쓰면 본인 포인터의 사이즈가 나오는거라
		요소의 개수를 구할 수 없다
			: 그렇다고 인수부분에서도 sizeof 를 못쓰는거 아니다
			원본이 있는 영역에서 그 배열명은 배열명으로썽의 ㅇ역할을 하기 때문에 sizeof()을 통해 정상적으로 사이즈를 구할 수 ㅇ있다.
				: ex)
				void ex(int * array,int n){
					int i;
					for(i=0;i<n;i++){ // n 없이 ex 함수 내에서 (sizeof(array)/sizeof(array[0])) 해봤자 소용없는거다
					printf("%d",array[i]);
					}
				}
				int main(void){
				int a[] ={1,2,3,4,5};
				ex(a, (sizeof(a)/sizeof(a[0]))); // 함수의 인수에서 sizeof 쓰는 것은 문제 없다
				return 0;
				}


	: 참고로 c언어에서는 배열형으로 매개변수를 설정할 수 있는데 컴파일러에 의하여 자동으로 포인터로 변환시키고 실행한다
		:따라서 매개변수 자리에서 선언된 배열의 사이즈는 무의미하고 아예사이즈를 지정하지 않아도 된다.
			ex) void func(int *array[]); // [] 안에 아예 아무것도 안써도 된다.
		:배열의 형태로 매개변수로 선언해도 포인터 취급받는거니까 어떻게 해도 함수 내부에서 sizeof 통해 개수를 구할 방법이 없으므로
		무슨 일이 있더라도 사이즈는 매개변수로 따로 받아야된다.(쓸ㅇ일이 있다면)
		:그냥 배열ㅇ을 인수로 할꺼면 포인터 써ㄱ라 굳이 배열로 받지말고 ㅁ






포인터배열: 요소가 포인터인 배열
	:선언형식
		자료형 *배열명[요소개수];
			: 자료형 == 각 요소들이 가리킬 변수의 자료형
			: [] 안이 사이즈가 아니라 요소개수인 이유는 포인터는 크기가 다 같은데 1바이트로 커버가능해서
	: char *배열명[] , 즉 char포인터배열의 경우 char형 문자열상수로 초기화 가능하다
		:각 요소가 char포인터명 이기 때문에 문자열상수값인 char형배열의 주소로 초기화 가능하다
			ex) char *array[]={"apple","pie","yummy"};

	: 활용
		1. 문자열의 주소를 요소로함 -- 문자열을 실제로 배열공간에 저장하는건 아님
		2. 문자열의 사이즈에 맞추어 동적할당하고 실제로 문자열을 요소로함
			:약간 자바의 배열과 비슷.
			레퍼런스변수 선언단계 == char포인터배열선언단계
			배열선언단계 ==  동적할당단계

	: 문자열상수 관련 배열종류
			1. 포인터배열
				:문자열의 주소를 요소로함
				:문자열은 별도의 메모리공간에 보관됨

			2. 2차원배열
				: max 길이를 기준으로 열이 만들어지므로 메모리 낭비가 있는편
				: 문자열자체를 배열공간에 저장

	 tb continued

*/


/*

/*


동적할당은 언제 사용할까:
	:자바와 다르게 정방형배열만 가능하다(모든 열의 사이즈가 같아야된다) ---> 각 행에서 낭비되는 메모리가 존재
	:경우
		:1. 동적할당을 사용한 문자열 처리
			: 임시적으로 넉넉한 문자열배열에 문자열 받아두고 strlen로 사이즈 get 해 malloc로 동적할당하고 strcpy 로 복사해 저장
			: malloc()의 인수로 들어갈 사이즈==  ' strlen(문자열) + 1'
				: strlen() 의 리턴값은 NULL문자 제외임을 주의



동적할당: 실행시점에 메모리 공간을 할당하는 것
	: 변수의 선언으로 메모리공간을 할당하는 것은 프로그램이 실행할때 이루어진다.
	: 동적할당은 가변메모리를 가진 배열이라고 보면된다.
	: 포인터의 초기화값으로 쓰여 포인터가 레퍼런스변수역할을 하게 한다.
		: 그러니까 포인터생성-->포인터가가리킬메모리공간확보-->포인터를 통한 메모리공간참조
	: malloc , free
		: stdlib.h 헤더파일에 포함되어있다
		: malloc() : 메모리를 동적으로 할당
			: void* malloc(unsinged int size); 가 함수의 원형이다
				: 반환형이 void* 형 ---> 포인터형태로 사용될 수 있는 아이란 뜻. 사용전 용도에 맞는 포인터로 형변환해 사용하란거
				: 만약에 정상적으로 동적할당이 이루어지지 않으면 NULL포인터를 반환한다.
					:NULL 포인터: 0번지
						: NULL 로 표기 되고 전처리 단계에서 0으로 바뀌므로 정수 0과 같으나 그냥 NULL으로 명시해서 써라

			: 사용형식 == 포인터로 형변환한 것을 초기화하여 사용한다
				(자료형*)malloc(sizeof(자료형));

					:ex) int* p = (int *)malloc(n*sizeof(int));
					:malloc() 괄호 안에는 바이트단위의 사이즈가 들어가야되는건데 컴파일러마다 크기가 다를 수 있으니 sizeof 써주는거다
					:n은 요소의 개수를 의미한다
						:같은 자료형의 변수들을 하나하나 동적할당해주는것보다 배열처럼 한번에 동적할당하는게 편하기때문
							:포인터를 마치 배열처럼 사용하면 된다.
								: 포인터명[n] = 배열명[n] , 포인터명+ n = &(배열명[n]) 이므로
									: scanf("형식지정자",&포인터명[n]);   // 배열명 자체가 아닌 요소 단위로 접근시 & 사용하는거 잊지x
									: printf("형식지정자",포인터명[n]); // 요소단위로 사용시 * 필요없음 주의
									: free(포인터배열명[n]) //  포인터배열의 요소 단위로 메모리 반환

					:포인터로 형변환해주는 이유는 malloc() 반환형이 void* 로 자료형을 따로 지정해주어야하는 포인터형이라서.

			: 동적할당에 실패하면 NULL 값을 반환한다
				:동적할당 시도 코드 다음에 반드시 NULL 값인지 체크햊줘야된다
					:실패시 exit(1) 을 사용한다
						:exit() == 프로그램을 즉시 종료시킨다.
							:예외상황이 발생해 종료시킬때 인수를 1로 주로함.

					:ex)
					int* p = (int *)malloc(sizeof(int));
					if(*p==NULL){
					printf("something is wrong here");
					exit(1);
					}

			: 동적할당한 저장공간을 다 사용한 이후에는 직접 free()써서 이후에 동적할당할 공간ㄴ을 많이 확보해두어야됨

		free(): 메모리 반환
			:형식
				free(동적할당된 포인터명);

			:malloc 쓰든 calloc쓰든 공통으로 쓴다
				: 메모리공간 확보를 위하여

	기타 동적할당시 유용한 함수
		:다른 얘들도 stdlib.h 에 포함되어있다
		calloc(): 동적 할당하는데 요소를 모두 0으로 초기화시킬때 유리
			: 원형
				void * calloc(unsinged int 요소개수 , unsinged 요소하나크기);
					:malloc 와 마찬가지로 반환형이 void*형이라 사용전에 포인터형변환해줘야됨
					:malloc는 전체 사이즈를 바이트 단위로 한번에 다 적게했다면 calloc는 * 를 분리하여 요소의 개수를 더 명시하게 한 느낌

			: 형식: malloc 와 사용형식 같다. 다만 별도로 값 초기화 안해도 이미 초기화 되있다는게 차이점
				 (자료형 *)calloc(n,sizeof(자료형));
				 	:ex) int *array = (int*)calloc(5,sizeof(int));

		realloc(): 동적할당된 포인터의 기존 정보를 유지하면서 사이즈를 변형하고 싶을때 사용
			:포인터의 사이즈를 늘리는 것 뿐아니라 줄일 수도 있다.---> 줄이는 경우 뒷자리의 데이터들이 순차적으로 썰린다
			:포인터 자기자신을 변형하지 않고 자기자신을 변형한 형태를 다른 포인터의 초기화 값으로 할 수도 있다.
				: 그냥자기자신에 할당하지 않고 다른 포인터에 할당하면 되는거임

			:원형
				void * realloc(void* , unsinged int);
					: 매개변수가 void* 라는건 모든 타입의 포인터를 매개변수로 할 수 있단 말이다

			:형식
				포인터명2 = (자료형*)realloc(포인터명1,변경사이즈);
					:포인터명2 == 포인터명1 이면 기존 포인터의 사이즈가 변경되고 , 기존포인터의 메모리가 재할당되는것
						: 포인터의 주소가 재할당된다면(썰리는게 아니라 메모리가 늘어나 메모리의 위치가 바뀐다면)
						 이전 메모리는 free() 같은거 없이도 자동삭제된다 <--- 가비지 처리이다. 아무도 참조하고 있는 얘가 없으니까
					:포인터명2 != 포인터명1 이면 기존 포인터는 유지되고 다른 포인터가 기존포인터의 정보를 가지며 초기화되는것
					:ex)
						int *p = (int*)malloc(5*sizeof(int));
				 		p= (int*)realloc(p,10*sizeof(int)); // 기존 포인터의 데이터를 유지하며 '사이즈' 변경
			 			int *z = (int*)realloc(p,11*sizeof(int)); // 기존포인터의 데이터를 새로운 포인터로 복사함

	


그냥 변수를 받는게 아니라 그 변수의 주소 값 받고, 해당 변수에 * 붙여서 써야 적용된다
	: 그냥 그 변수 자체는 그 주소를 담은 포인터일 뿐 실제 값을 변경 시킬 그럴짬이 안되고, 어딜 가리킬지 결정밖에 못한다











구조체: 사용자정의자료형  <---typedef는 자료형명 재정의 이다. 사용자정의자료형이라고하지 않는다
	: 다양한 자료형의 요소 즉 멤버를 취할 수 있다
	: 구조체선언
		struct 구조체명{멤버선언};
			: 함수 내부에서 정의되면 그 함수에서만 쓸 수 있다
			: 선언했다고 메모리공간 차지하는거 아니다
			: 구조체도 함수와 마찬가지로 원형선언하면 사용시점보다 더 뒤에서 선언되어도 오류가나지 않는다
			: 멤버는 배열, 포인터 , 다른 구조체 까지 다 가능
		 		: 구조체를 멤버로 하는 경우 상식적으로 . 사용해서 쓰면 된다
				 	ex)
					 struct student_profile{
					 	int age;
					 	double grade;
					 };

					 struct person{
					 	struct student_profile student;
					 	char name[100];
					 };

		 			int main(void){
					 	struct person jiyu;
					 	jiyu.student.age = 19;
					 	jiyu.student.grade = 4.5;
					 	strcpy(jiyu.name ,"jiyu");
					 }

	: 구조체변수선언
		struct 구조체명 변수명;
			: struct 구조체명 == 사용자정의자료형
			: 변수를 선ㄴ언하고 나서야 비로소 메모리 할당됨
				: 구조체변수 크기 == ' 각 멤버의 크기의 총합 +알파 '
					:딱 각 멤버의 크기의 총합이 아닌 이유는 '패딩바이트'가 존재하기때문.
					즉 가장큰 멤버의 크기가 직사각형의 한변이 된다
						:패딩바이트를 최소화하기 위해선는 멤버선언순서가 중요하다---최대한 빈칸없이 만들어라
						:패딩바이트) 바이트 얼라인먼트 를 위해 쓰이는 바이트
							:바이트얼라인먼트) 메모리를 가지런하게 정렬하는것. 즉 직사각형꼴로 만드는것

			: 여러개의 구조체변수를 한번에 선언할 수 있고 심지어 중괄호를 이용한 초기화까지 가능하다
				ex)
					struct nojam jiyu={"jiyu",10}, yuha={"yuha",12} ;

	: 초기화
		1. 멤버단위
			: 구조체명.멤버명;
		2. 통째로
			:{} 사용
		3. 이미 초기화된 다른 구조체변수를 대입 --> 같은 타입이어야됨
			:ex)
			struct fuck a={1,"uiui"};
			struct fuck b= a;

	: 참고로 구조체선언, 구조체변수선언, 구조체변수초기화 ㄹ를 한방에 진행 가능
		ex)
		struct animal{
			int age;
			char *name;
		}rabbit = {16,"rabbit"};

	: 구조체와 함수
		: 사용자정의타입은 매개변수 뿐 아니라 반환형도 될 수 있다
			: 구조체변수를 매개변수로
				:구조체변수의 멤버값을 단순히 꺼내쓰고 싶을때 사용한다.
					:구조체변수가 포인터는 아니므로 함수 내부에서 수정한다고 바뀌는게 아니다
						: 만약에 구조체변수의 값을 함수 내부서 변형시키고 싶은거면 구조체포인터를 매개변수로 해야된다.

			: 구조체를 반환형으로
				: (함수 내부에서 사용된 구조체변수명은 리턴되지 않지만) 멤버들값을 반환된다.


	: 구조체와 포인터
		: 구조체를 가리키는 포인터를 만들고 싶으면 구조체형으로 정의하면 된다.
			:주로 함수에서 구조체변수값을 직접변경하고 싶을 때 매개변수로써 잘 사용됨
				ex)
				void change(struct chubby *x){
					x->kg = 100;
					x->age = 18;
				}

		:구조체포인터 선언 형식
				struct 구조체명 *포인터명;

		: 구조체변수의 주소== 멤버전체의 주소
			: *포인터명 == 구조체변수명
				: 멤버접근연산자의 우선순위가 간접참조연산자보다 높으므로 포인터를 통하여 멤버에 접근할때 괄호 꼭 써라.
					:ex)
						struct dummy hojun={39,"hojun"};
						struct dummy * p = &hojun;
						(*p).age = 88;

		:간접멤버접근연산자
			:포인터로 멤버에 접근할때 쓰인다
			:형식
				포인터명 ->멤버명 ; // (*포인터명).멤버명 이랑 같은 뜻
					:ex)
						struct dummy hojun={39,"hojun"};
						struct dummy * p = &hojun;
						p-> age = 88; //==(*p).age = 88;

			:포인터연산적용하면서도 사용가능
				ex)

				int i;
				for(i=0 ; i<size;i++){
					printf("%lf %s %lf", (p+i)->score , (p+i)->name , (p+i)->gpa);
				}


			:여러개 한번에 사용가능
				ex1) head->next->value // == (*((*head).next)).value
					: 구조체포인터 멤버를 가질때 그 멤버가 가리키고 있는 구조체를 ->를 이용해서 접근한것

				ex2) a->num = b->num = 10; // (*a).num = (*b).num = 10;

		:구조체배열
			:같은 구조체타입의 변수가 많이 필요하다면 사용
			: 한번에 초기화 할땐 중괄호를 두번 씀 됨
				ex) struct dummy array[]={{39,"hojun"},{29,"jojun"},{19,"uojun"}};

		:자기참조구조체
			:자기타입의 포인터를 멤버로 하는것.
			:관련된 데이터를 하나로 묶어 관리하기 위해 사용
			:연결리스트(링크드리스트)에 사용됨
typedef: 자료형이름제정의
	:형식
		1.선언이후에 적용
			 typedef 기존자료형명 새로운자료형명;

				 :되도록이면 2번 방법써라 . 1번 방법은 기존자료형명도 써야되는 경우에 써라.

		2. 선언과 동시에 적용
			typedef struct{

			}새로운자료형명;

				: 구조체명을 써도 되긴 되는데 굳이? 어차피 새로운 자료형명으로만 쓸거면서
*/

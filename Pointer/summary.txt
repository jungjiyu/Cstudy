Call By Value 
	: 값만 전달한다. 원본 값에 영향을 주지 않는다 (지역 변수 값만 깔짝 바뀌겠지)
	: C 언어 해당 << 암기 : C Val 씨 발
	: https://programist.tistory.com/entry/C-%EC%96%B8%EC%96%B4-Call-by-Value%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C-Call-by-Reference%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C%EC%9D%98-%EC%9D%B4%ED%95%B4

	: Call By Reference 
		: 참조를 전달하는 방식. 원본 값이 바뀐다
		: C언어에서 공식적으로 지원하지 않지만 포인터로 흉내내는거다



-----------------------------------------------------------------------------------------------------------------------------------

<포인터>

1. 포인터 = 다른변수의 메모리 주소를 저장하는 '변수'
	: 선언
		: 자료형 * 포인터명;
			: 선언할때 쓰이는 * 은 간접참조연산자가 아닌 그냥 일반적인 변수와 포인터 변수의 선언을 구분하기 위한 기호

			: 가리킬변수의자료형== 포인터명 앞에 간접참조연산자 하나만 남기고 남은 형태
				: 이 타입으로 포인터연산을 하게 된다.

			: 포인터의 자료형 == 포인터명 앞 전체부분
				ex) int **b ; // int * == 가리킬변수의 자료형 , int ** == 포인터의 자료형



	: 초기화 >> 변수의 주소나 동적할당결과의 주소값으로 초기화한다.
		:포인터는 반드시 초기화 한 이후에 활용가능하다.
			
		
	: 포인터의 크기 
		: 포인터들끼리 자료형이 다르더라도 포인터의 크기가 같다
			: 32비트 운영 체제 기준 4바이트, 64비트 운영 체제 기준 8바이트
			: 포인터들끼리 크기가 같은데도 가리킬변수의 자료형을 명시하며 선언하는 이유는 참조단위를 결정하기 위함이다.
				:그 단위로 해당 위치에서 값을 읽어오고, 그 단위로 포인터 연산을 하게 된다.		


	: 포인터 연산
		:주소가 정수값이긴 해도 일반적인 정수와 다르게 다루어진다.
		:주소 + 정수 == 주소 +  (정수*변수크기)
		: ex)
			int a = 10;
			int *p = &a; // &a ==0 일때
			printf("걍p: %d , p+1 = %d", p , (p+1));  //p == 0 이고 , p+1 == 4 이다

-----------------------------------------------------------------------------------------------------------------------------------


<다중포인터>

다중포인터: 포인터의 주소를 값으로 하는 변수

	:선언형식
		자료형** 이중포인터명;

			: 가리키는 단위는 (자료형*) 
				: 그러니까 포인터 연산 단위도 
			: 이중포인터의 자료형은 (자료형**) 

	:초기화형식
		이중포인터명=&포인터명;

	: 헷갈정리
		이중포인터명 == 단일포인터주소
		*이중포인터명 == 단일포인터값==단일포인터가참조하는변수주소
		**이중포인터명 == 변수값 == 단일포인터가참조하는변수의값

	:활용
		1. 포인터값을 바꿀때(포인터가 어떤 변수를 가리킬지를 바꿀때) 매개변수로 사용
			
		2. 포인터배열을 매개변수로 받는 함수
			배열명 == '0번째 요소의 주소' 이므로 배열명도 일종의 포인터라고 할 수 있다(변경이 불가한 것 뿐)
			따라서 포인터배열명 == '0번째 요소의 주소' == '포인터의주소' == '이중포인터명'


-----------------------------------------------------------------------------------------------------------------------------------

<포인터와 배열>


0. 배열에서 " 배열명 == &배열명 " 인 이유  
	: 배열의 0 번째 요소의 주소 == 배열자체의 (시작) 주소 이기 떄문



1. 배열명 
	: 포인터 상수로, 배열의 0번째요소의 주소를 가리킨다
		: 따라서 '배열명++' 같은건 불가


	: 배열을 인수로 받을떄 포인터를 매개변수로 하는 이유
		: 모든 요소를 넘기지 않아도 포인터 연산을 통하여 모든 요소에 접근이 가능하니까

	: 함수에서 인수로 배열을 받고 그 사이즈를 사용해야할 일이 있으면 매개변수 부분에서 사이즈를 따로 받아둔다
		: 아무리 포인터가 배열을 가리키는 경우라해도 sizeof 연산자를 쓰면 본인 포인터의 사이즈가 나오는거라 요소의 개수를 구할 수 없다
			: 그렇다고 인수부분에서도 sizeof 를 못쓰는거 아니다
				: 원본이 있는 영역에서 그 배열명은 배열명으로썽의 ㅇ역할을 하기 때문에 sizeof()을 통해 정상적으로 사이즈를 구할 수 ㅇ있다.
				

	: 참고로 c언어에서는 배열형으로 매개변수를 설정할 수 있는데 컴파일러에 의하여 자동으로 포인터로 변환시키고 실행한다
		:따라서 매개변수 자리에서 선언된 배열의 사이즈는 무의미하고 아예사이즈를 지정하지 않아도 된다.
			ex) void func(int *array[]); // [] 안에 아예 아무것도 안써도 된다.
		:배열의 형태로 매개변수로 선언해도 포인터 취급받는거니까 어떻게 해도 함수 내부에서 sizeof 통해 개수를 구할 방법이 없으므로 무슨 일이 있더라도 사이즈는 매개변수로 따로 받아야된다.(쓸ㅇ일이 있다면)






2. 이차원배열
	ary[ i ][ k ] ==  *( *(ary+i) + k ) 
		: ary + i == i 번쨰 요소의 주소 
		: *( ary + i ) ==  i 번쨰 요소의 값 == i번쨰 1차원배열의 0번째 요소의 주소
			: 이떄 ary + i 값과 *( ary + i ) 값이 같게 나오는 것은 , 배열자체의 주소와 배열의 0번쨰 주소값이 같기 때문

		:  *(ary+i) + k  == i 번쨰 1차원 배열의 k 번쨰 요소의 주소
		: *( *(ary+i) + k )== i 번쨰 1차원 배열의 k 번쨰 요소의 값


	int ary[ i ][ k ] 를 int (*p)[ k ] 로 대체는 가능, 근데 똑같진 않음
		: 둘다 int [k] 단위
		: 다른점>> ary 는 int [k] 타입 요소를 i 개 제한해서 가지지만 , p 는 딱히 제한이 없음
			: int ary[n] 과 int *p의 차이와 비슷한거임

	int *p[k] 와 int (*p)[ k ] 의 차이점 		: int *p[ k ] >> 포인터 배열
			: int* 타입의 요소를 k 개 가지는 배열

		: int (*p)[ k ] >> 배열 포인터 
			: int [k] 타입의 요소를 가리키는 포인터 하나




----------------------------------------------------------------------------------------------------------------------------------

<포인터 선언에서의 '*' tip>
	1. 포인터선언할때 쓰이는 가장 끝 * 하나는 무조건 그냥 타입 명시위해 쓰는거. 굉장히 무의미 
	2. 포인터 선언할때 쓰이는 가장 끝 * 하나 뗀 타입이 참조당하는 대상의 타입
	3. 쌩 포인터변수는 할당 받은 값 그 자체
		: ex)  int* tmp = *ppa; 에서 tmp 값이 *ppa 이고, *tmp 값은 **ppa 이다.

<배열에서 '*' 과 '[ ] ' tip>
	1. * 하나당 [ ] 하나이다
		: ary[ i ][ j ] == *( *(ary+i) + k )
		: ary[ i ] == *(ary+i) 

	2. 배열명의 타입 == 젤 가까운 [ ] 하나에  '(*)' 넣은 타입 
		: int array[4] --> array 는 int * 타입
		: int array[3][4] --> array는 int(*)[4] 타입
			: array[n] 은 int * 타입

	3. 배열의 타입 해석 tip
		: 정리했을때 괄호로 묶인 * 가 있을 경우>> (*)  는 걍 버리고 , 남은 부분을 요소의 타입으로 생각하며, 해당 변수를 포인터 취급
			: (*) 는 포인터로 선언하기 위해 소비된 단순 '*' 이다
			: ex)  int array[3][4] --> array는 int(*)[4] 타입 --->  array 는 int[4] 타입의 요소를 가지는 포인터 변수 하나
		: 정리했을때 괄호로 안묶인 *가 있을 경우  >> * 까지 요소의 타입으로 생각, 해당 변수를 배열 취급
			: int *array[4] -->  array는 int * (array[4])  타입 --> >  array 는 int * 타입의 요소를 4개 가지는 배열
	





<함수에서 포인터 이용 swap 할때 tip>

규칙과 원리
	1. 대상주소를 받는 파라미터
		: 선언 >> 변경대상보다 * 하나 더 붙여서
			: 내부의 변경 사항을 외부에서도 적용시키기 위해 우리는 '변경대상의값'이 아닌 '변경대상의주소'를 arg 로 받는다. 따라서 변경대상의 주소를 값으로 하기 위해 파라미터는 변경대상보다 * 가 하나 더 필요하다. 


		: 함수 내부서 활용 >> 파라미터 변수에 * 딱 하나만 붙여서
			: 파라미터가 변경 대상의 주소이므로 , * 를 하나만 씀면 변경 대상의 값에 참조할 수 있다


	2. tmp 변수
		: 선언 >> 파라미터변수 선언할때보다 * 하나 덜 붙여서
			: 파라미터는 변경 대상의 주소를 받기 위해 * 를 하나 더 붙인 것이므로, 변경대상의 값을 담기 위해선 파라미터에서 * 하나 땐 타입의 변수로 받아야된다

		: 할당하는값 >> 파라미터 변수에 * 딱 하나만 붙여서
			: 파라미터가 변경 대상의 주소이므로 , * 를 하나만 쓴건 변경 대상의 값이다

		: tmp 변수 활용  >> * 아예 안붙여서
			: 할당받은 값 자체 == * 을 다뗀 포인터 변수 이기 때문




<함수에서 n차원 배열 받아서 쓸떄 tip >
	0. 읽기만 잘 되면 성공임
		: 배열값은 읽으나 수정하나 모두 '*' 가 들어가기 때문에 읽기가 되면 수정도 되는거임
 
	1. 기본적으로 배열을 받는 param 하나 , 배열의 요소 개수를 받는 param 하나
		: 이차원 배열의 경우에도 배열 요소의 개수를 받는 param 은 딱 하나

	2. 일차원배열 받는 param 은 *p
		
	2. arg 가 이차원배열일때 parm 은 << **p 가 아님을 주의
		1) int p[ ][사이즈]
		2) int (*p)[사이즈]
			: p를 걍 2차원 배열명처럼 활용
		3) int *p
			: 별도로 i 에 조작질해줘야됨


	3. parm 을 이중포인터로 하여 받는 경우는 포인터 배열밖에 없음


-----------------------------------------------------------------------------------------------------------------------------------

<포인터배열>

포인터배열: 요소가 포인터인 배열
	:선언형식
		자료형* 배열명[요소개수];
			: 자료형* == 요소의 자료형 == 요소가 포인터

	: char *배열명[ ] , 즉 char포인터배열의 경우 char형 문자열상수로 초기화 가능하다
		:각 요소가 char포인터이고,  문자열상수는 char형배열이기 때문
			ex) char *array[ ]={"apple","pie","yummy"};

-----------------------------------------------------------------------------------------------------------------------------------
<void 포인터>
	: 가리키는 대상의 자료형이 미정인 포인터
	: 사용법)
		1. 주소 대입: 일단 대상의 주소를 받는다
		2. 포인터 형변환: 포인터를 활용하기 전에(간접참조연산자 사용전에) 포인터를 형변환한다.
			: 단순 print 하는 것도 그냥 void 인 채로 형식지정자 같은데 넣어 쓸려함 오류난다
				ex)
				int a =10;
				void *vp = &a;
				printf("%d",*(*int)vp); // 그냥 *vp 함 오류난다.


	: void 포인터를 다른 자료형의 포인터에 대입 가능하다. 
		: 딱히 형변환 없이 void 포인터만 대입해도 문제가 되진 않는다(해당 포인터로 자동 형변환 된다.)
			ex) 
			int a=10;
			void *vp = &a;
			int *ip= vp;

	:범상치 않은 포인터의 연산도 가능
		void(*vp);
		int array_2[ ][3] = { {1,2,3},{4,5,6},{7}};
		// array_2 의 자료형 >> int (*)[3] . 즉 int [3] 타입의 변수를 가리키는 포인터.
		vp = array_2;
		printf("%d",*(*((int(*)[3])vp +1)+2));


----------------------------------------------------------------------------------------------------------------------------------









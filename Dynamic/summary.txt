
동적할당: 런타임에 메모리 공간을 확보하는것
	: 관련 함수는 stdlib.h 헤더파일에 포함되어있다	
	: 가변적인 배열로 주로 사용된다.		
	: 동적 할당 방법
		: malloc, calloc 반환값을 저장하는 포인터의 경우 주로 *포인터명 으로 일종의 변수처럼 사용한다 보면 됨.  즉 공간을 언제든지 회수 할 수 있는 변수처럼 생각함됨. ( 포인터이긴해도, 다른 변수의 주소를 저장하기 위해서 쓰이진 않음 )
			: 동적할당을 사용하는 이유가 변수 , 배열의 공간을 실행 도중에 동적으로 확보하기 위해서이기
			  때문에 동적할당 받은 포인터에 보통 &(변수)를 대입하는게 아니라 (변수는 공간이 완전 잡혀있는 얘니까 굳이 동적할당을 사용하는 의미가 없어짐.)
			 *포인터 = 원하는값 을 직방으로 넣고 *포인터의 형태로 변수처럼 사용하는 것.
				:ex)
					int *p = (int *)malloc(sizeof(int));
					*p = 10;
					printf("%d",*p);


		: malloc, calloc 반환값을 저장하는 포인터의 경우  변수 중에서도 배열타입 변수처럼 자주 사용됨
			: *( 포인터명+n )==포인터명[n] = 배열명[n] , 포인터명+ n = &(배열명[n]) 이므로
				: scanf("형식지정자",&포인터명[n]);   // 배열명 자체가 아닌 요소 단위로 접근시 & 사용하는거 잊지x
				: printf("형식지정자",포인터명[n]);
				: free(포인터배열명[n]) //  포인터배열의 요소 단위로 메모리 반환가능
					// 아니 그럼 배열 통째로 반환하는건 안됨?




		: 주의 ) 동적할당을 여러번 시행할때 서로 연속적이지 않을지 몰라도, 각각 그 자체적으로는 연속적인 메모리가 확보되는거다.  

		(1) void* malloc(unsinged int size); 
			: 반환형이 void* 형 ---> 사용전 특정포인터타입으로 형변환해 사용한다
				: 만약에 정상적으로 동적할당이 이루어지지 않으면 NULL포인터를 반환한다.

			: 주로 arg 로 직접적인 사이즈를 쓰기 보단 " n*sizeof(타입) " 과 같이 쓰는 편
				: 컴파일러 따라 자료형의 사이즈가 다르게 정의될 수 있으니
				: n == 요소의 개수

		(2) void* calloc(unsignedint n , unsinged int size);
			: malloc기능+ 요소개수따로 받기+ 0으로 자동 초기화기능
			: 첫 arg == 배열 요소 개수 , 두번쨰 arg == 한 요소당 size
				: 그러니까 사이즈 자체는 malloc(n*sizeof(자료형)) == calloc(n, sizeof(자료형))

	: 동적 할당 변경 방법
		: void * realloc(void *, unsinged int ) 
			: 동적할당 받았던 메모리의 크기를 변경한다. 
				: 크기를 늘리는 경우 저장된 내용은 유지되면서, 뒷 부분이 늘어난다( 새로 추가된 부분은 쓰레기 값으로 채워진다). 
					: 기존 데이터가 유지되는건 맞는데, 메모리 위치가 유지되는건 보장 못함 주의

				: 크기를 줄이는 경우 마찬가지로 뒷 부분이 줄어든다

			: 첫 arg 로는 이미 동적할당된 부분을 참조하고 있는 포인터, 두번째 arg 로는 변경될 사이즈를 할당한다
			: 주의 ) 
				1. 그냥 arg 로 해당 포인터를 대입하는걸로 끝내면 안되고, 다시 재할당받아야된다.
					: 기존 데이터가 유지되는건 맞는데, 메모리 위치가 유지되는건 보장 못한다
						: 참고로 realloc 로 인해 쓸모없게된 메모리영역은 자동으로 반환되므로 노상관.
					: ex) 
						int *p = (int *)malloc(6*sizeof(int));
						p = (int *)realloc(p,8*sizeof(int)); // arg 로 대입하고, 다시 반환 받는다

				2. 반환타입이 void* 이므로 재할당할때 강제형변환 필수
				3. 두번째 arg 는 단순 요소 개수가 아니라 "사이즈"( 개수 * sizeof(타입)) 임을 주의

	: 동적할당메모리반환 )  메모리 공간을 공용 메모리로 돌리는 작업
		memory leak >> 더이상 사용하지 않는 메모리를 계속 붙잡고 있어서 과부하 걸리는것
			: memory leak 을 방지하기 위하여 더이상 사용하지 않는 얘들은 바로바로 반납하자

		댕글링 포인터(Dangling Pointer) >>  해제된 메모리 영역을 여전히 가리키고 있는 포인터
			: https://thinkpro.tistory.com/67
			: 요약하자면, free(특정포인터) 한 후에 바로 특정포인터=null; 해주는게 좋다
			: 동적할당 메모리를 반환하면,  거기에 저장한 값은 날라가고 쓰레기 값으로 채워지는게 맞다. 그런데 반환된 공간을 사용한다고 해서 에러가 나지도 않고, 대부분 값이 제대로 나온다. 하지만 해당 메모리는 공용 메모리로 돌려진 상태라 어떤 상황이 발생할지 예측불가하므로, 해제된 메모리에 값 저장하지 말자. 할거면 새로 공간을 할당하여 사용하자
				: 댕글링 포인터 ex)
 					int *p2 = (int*)malloc(sizeof(int));
					*p2 = 10;
					printf("동적할당된상태에서의 값: %d \n",*p2);
					free(p2);
					printf("메모리 해제된 상태에서의 쓰레기값: %d \n", *p2);
					*p2 = 10;
					printf("메모리 해제된 상태에서 값(10) 넣었을때: %d ", *p2);


		: free( 포인터 ) 를 사용해서 한다
		: 주의 
			1. 일차원 가변적 배열로 사용한 포인터의 경우 걍 그 포인터만 free 시키면 되지만, 이차원 가변젹 배열로 사용한 포인터의 경우 일단 "요소단위로 free 한 다음에" , 마지막으로 "이차원가변포인터를 free" 시켜야된다
			2. 이미 free 한 메모리를 또 free 하면 에러난다




		

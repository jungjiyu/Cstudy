<기본 구성>

	: #define CRT_SECURE_NO_WARNINGS >> visual studio 상에서 보안상의 이유로 경고를 발생시키는 scanf, strcpy 등을 사용할 수 있게 함. 
	: #include <stdio.h>  >> printf 와 같은 함수를 사용 가능하게 함
		: 해석
			: stdio == STaandard Input Output
			: h == 파일의 확장자 . 헤더 파일
		



#include <stdio.h>
#define CRT_SECURE_NO_WARNINGS

int main() {


	return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------------------
<변수>


리터럴
	: 기본적으로 정수값은 int 형값
		: long 형은 뒤에 L 따로 붙임

	: 기본적으로 실수값은 double 형값
		: float 형은 뒤에 f 따로 붙임

	: 문자열상수
		:프로그래밍 코드 자체의 문자열상수만 문자열 상수다
			: 그러니까 gets() 나 scanf() 로 받은게 문자열상수는 아니다. 
				: 걍 일련의 데이터 이므로 직접 공간 확보를 한 후에(배열을 만들든 동적할당을 하든) 써야한다	
					:
					char *p;
					gets(p); 이런식으로하면 오류나지만 
	
					char *p = (char*)malloc(80); 
				 	gets(p); 처럼 하면 오류 안난다. (공간을 확보하고 써야된다.)


		: 문자열상수는 끝에 NULL문자 추가된 형태로 읽기전용 메모리영역에 char배열 형태로 따로 저장된다			: 문자열상수==  char 배열명 >> 주로 char 형 포인터에 할당해 사용한다
			1. char 포인터에 대입하여 사용가능
				:ex) char *p = "apple" ;
				: 물론 포인터 연산을 통한 인덱스변 접근도 가능
					ex) printf("%c",*("apple"+4)); // 결과 == 'e'

				: 문자열은 수정할 수 없다. 읽기전용메모리에 있으니까. 

			2. 형식지정자를 %c, %s, %p 등등 사용가능
					ex) printf("%p","apple");
					ex) printf("%c",*"apple"); //a출력

			3. 인덱스별 접근이 가능
				ex) printf("%c","apple"[2]); // 결과 == 'p'

	: 같은 문자열 상수의 경우 하나만 저장되고 , 공유된다. 




아스키코드:128개의 문자를 0~127 의 정수에 매치시켜놓은 것
	: 문자상수는 정수처럼 다룰 수 있기에 연속된 조건문 부분에서 정수다루듯이 다룰 수 있어 사용이 편리하다
	: 아스키코드를 일일이 외울 필요는 없지만 알고있어야할 특징:
		1. 연속된 알파벳,숫자는 연속된 아스키코드값을 가진다
			:숫자는 '0'~'9' 까지만 있다 --> 20 을 입력해도 '2' , '0' 따로 받는거다 
		2. 소문자가 대문자보다 아스키코드값이 크다
		3. 제어문자(이스케이프문자) 도 아스키코드값을 가진다


		
문자관련함수: getchar(), putchar()
	: 굳이 쓰는 이유) scanf 나 printf 는 문자 뿐 아니라 사이즈가 더 큰 정수까지 입력,출력하는 기능이 포함되있어
	문자만 입력하는 함수에 비해 크기가 큰데 문자 전용입출력함수를 사용하면 더 효율적 
	
	getchar();
		:원형) int getchar(void);
			: 반환형이 int 인 만큼 int 형 변수로 받는게 유리하다 
				: scanf에서 이러라는게 아니라 getchar() 쓸때를 말하는거다
				 
			:참고로 반환형이 char 이 아니라 int 형인 이유 
				: ctrl+z 는 입력을 종료한다는 건데 이게 -1 의 값을 가진다 
				: 데이터를 다른 자료형의 변수에 할당할 때 
				받을 변수의 사이즈 만큼 잘라서 받는데(뒷부분부터) 이때 잘라서 받을 데이터의 가장 앞비트는 유지한채 받게 된다. 
				그럼 int 로는 00000000000000000000000011111111 인 +255 는 char 변수의 형태로 할당될때 11111111 이 되므로 
				결론적으로는 -1 이 되버리고 만다. 따라서 이를 구분하기 위해서는 int 형 변수의 형태로 반환해야되고, int 형 변수로 할당받아야된다. 
					: 물론 키보드로만 입력받는다고 하면 0~127 까지의 숫자만 할당되겠지만 입력경로가 파일이 되는 경우 반환값이 255가 가능해진다 
					: 참고로 unsinged 자료형이었던 데이터를 다른 자료형의 변수로 받는다고 할떄 이때는 할당받을 데이터의 젤 앞비트값이 뭐였든지간에 무조건 0으로(+로) 들어간다 
			: 문자단위로 받은걸 문자배열에 저장해서 문자열로 사용하려할때 직접 끝에 '\0' 달아줘야되는거 주의
				: 근데 굳이 이러지 않고 싶으면 처음부터 {} 로 걍 초기화 해주면 기본적으로 모든 요소가 '\0'으로 초기화되서 따로 처리안해줘도 됨 
				: 보통 문자연속으로 입력할때 쓰인 i 로 끝 인덱스 캐치하여 마지막 인덱스 알아냄  
					int c,i=0; // 문자를 받는건데도 int 로 받는것은 getchar() 이 255 을 반환할 수도 있으니까 -1 처리되지 않게 하는것  
					c = getchar();
					while((c!='\n')&&(i<size-1)){ //(c!='\n') 써준거는 꼭 size꽉채워 다 입력 안받을 수 있으니까 . 
						str[i] = c;
						c= getchar(); 
						i++;
					} 
					str[i] = '\0'; // i == size-1 == 젤 끝 인덱스 .  
	putchar();
		:원형) int putchar(int);
			:반환형이 int인 이유는 출력과정에서 오류 발생시 -1을 반환하기 때문
			:엔터없이 출력한다 

		
대문자-> 소문자로 쉽게 바꾸는 법: 
	: 대문자의 아스키코드값이 소문자의 아스키코드값보다 작은 것을 고려하여 'a' - 'A' 한 값을 해당 소문자에 더한다
		ex)
		char c=z;
		printf("%c의 대문자: %c",c , c+('a'-'A') );

		: 이와 같은 원리로 소문자 -> 대문자로 바꾸기 위해서는 'A' - 'a' 한 값을 해당 대문자에 더하면 되는 것을 알 수 있따
*/




NULL 과 '\0'
	: NULL >>null 값. 아무것도 안가리킬떄의 참조값
	: '\0' >> null 문자. 문장의 끝에 붙임	
		: 이건 화이트 스페이스랑 다른거임 주의


이스케이프문자
	: \n == 엔터
	: \ 찐으로 쓰고 싶음 \\ 쓴다


 자료형 과 형식지정자
	정수형 <<사실 정수형의 경우 unsigned  도 가능	
		char , %c
			: 1바이트!!! . 아스키코드만
			: char 에도 음수 저장가능함 주의
			
				
		int , %d
			: 4바이트
		long , %ld
			: 4바이트
		long long , %lld  
			: 8 바이트

	실수형 
		float , %f
			:4바이트
		double, %lf
			: 8바이트

	기타
		%s:
			1. scanf() 로 입력받을때
				:  \n "전"까지 단어 단위로 받고, 그 뒤에 자동으로 '\0'을 더한 문자열을 반환한다  
					: 결국 '\n' 는 버퍼에 남는거 주의
					ex)
					char str[500];
					scanf("%s",str);scanf("%s",str); 했는데 'apple jam 엔터'하면 "apple\0" , "jam\0" 이 한꺼번에 저장된다.  (\n 이 수거되지 않고 있다)
			
			 
			2. printf() 로 출력할때 
				: 포인터 연산방식으로 작동한다. '\0' 이전의 내용까지 출력한다 
				: %s를 사용하는 원리
					:일단 기본적으로 char형 배열명을 대상으로 사용하고, 포인터 연산을 사용하여 NULL문자이전까지의 문자값을 출력한다.
						ex)
						char *p = "north";
						whlie(*p !=NULL){
							printf("%c",*(p++)); // p도 포인터이므로 포인터연산을 통하여 다음요소의 주소를 가지게할 수 있다.
						}


		%p >> 포인터에 저장된 주소 출력

유명한형변환
	: 자동형변환 << 대부분 더 커지는 쪽으로 변환. 데이터 손실을 최소화
		1. 정수의 승격	
			 정수끼리의 연산 >> 각 피연산자가 int 로 승격
		2. 정수가 실수화
			정수피연산자와 실수 피연산자로 연산 >> 정수피연산자가 실수화

		3. 할당에서의 자동형변환
			: 큰쪽애서 작은 쪽으로, 작은 쪽에서 큰쪽으로 둘 다 일어난다
 
	: 강제형변환 
		1.  정수를 실수화
			: 정수/정수 연산으로 소수점 까지 구하고 싶을때 

------------------------------------------------------------------------------------------------------------------------------------------------------
<출력>

printf("형식지정자짬뽕문장", 변수);

------------------------------------------------------------------------------------------------------------------------------------------------------

<입력: scanf 와 형식지정자 , 기타 문자 && 문자열입력함수>

scanf
	: https://namoo-gamedev.tistory.com/9
	: 키보드로 입력한 값은 버퍼에 저장되있다가 입력이 종료되면 버퍼에서 해당 데이터를 scanf 함수가 읽어오는거다.
		: 엔터를 기준으로 입력의 종료를 받아들인다. 입력의 종료시 scanf 함수는 버퍼에서 값을 읽어는오는데, 주어진 형식지정자에 대응하는 데이터만 get 해오고, 중간 중간의 화이트 스페이스는 구분자로 쓴다
			: 화이트 스페이스 이외의 구분자를 쓰고 싶으면 형식지정자들 사이에 , 나 # 같은걸 명시한다.
				

scanf와 형식지정자
	: 형식지정자는 scanf 에서는 명확히 지켜야하지만, printf 에선 꼭 지킬 필욘 없음
	: % 문자를 문자료 쓰고 싶음 %% 로 쓴다.
	: 화이트 스페이스
		: 형식지정자들 중 %c 만이 버퍼 상에서 화이트 스페이스를 수거할 수 있다.
			: 화이트 스페이스도 문자의 일종이기에 %c 가 받을 수 있는거다
			: %s 도 수거는 못한다
		   ****: 주의 ) %c 도 입력 받을때 엔터를 남긴다

		: %c , %s 를 포함하여 scanf 로 데이터를 입력받으면 뒤에 모두 엔터를 남긴다..
 			: 그렇다고 입력받는 과정에서 입력한 화이트 스페이스를 모두 남긴다는건 아니다
				: get 해야하는 데이터를 얻기 "전"까지 입력된 화이트 스페이스는 단순 구분자의 용도로 쓰이는거라 따로 남기지 않고 그냥 알아서 버려지는거고, 마지막에 입력 종룔 의미하는 엔터만 남는다
			: %s 의 경우 엔터'전' 까지만 scanf 가 읽어들이고, 뒤에 '\0'을 추가해주는거지, \n까지 수거한 후 그걸 \0 으로 바꿔주는게 아니다
				: 그건 scanf ( ) 가 아닌 gets(  ) 의 작동방식이다
			: %c 의 활동에 영향을 줄 수 있어 이후 별도 처리가 필요
				sol1 >> 입력 받고 나서 별도로 getChar( ) 이나 scanf("%c", &c); 쓴다
				sol2 >> 걍 이후에 %c 를 입력받아야하는 상황일때 앞에 스페이스바 입력하고 쓴다
					: 이렇게 하면 %c를 입력받을때도 화이트 스페이스를 무시하겠단 소리가 되서 , 버퍼에 화이트 스페이스가 남아있어도 그냥 무시한다


문자 입력전용 함수 int getchar( ) 
	: 주의 >> int 형 변수로 반환 값을 받아야한다
		: 파일의 끝이나 오류를 나타내는 값으로 -1 이 반환될 때도 있어서 그렇다

문자 출력전용 함수 putchar( int n ) 
	: 걍 putchar(변수); 이런식으로 씀 된다

문장 입력 함수 gets(char배열명); 
	:  scanf("%s") 보다 더 센스있게 \n 까지 읽어들이고, 그걸 \0 으로 바꾸는 방식으로 반환하기 떄문에 입력받고 나서도 버퍼가 깔끔하다
	: 얘로도 버퍼 상의 \n 을 치울수가 있다
	: string.h 포함 후에 사용필요


문장 출력 함수 puts(char배열명);
	: string.h 포함 후 사용 필요

------------------------------------------------------------------------------------------------------------------------------------------------------
<함수>

함수 원형  Prototype  선언
	: 함수의 헤드 부분만 적는다
		: 끝에 ' ; ' 적어야 하는거 주의 
	: 함수의 원형을 따로 선언하지 않으면 함수의 정의와 선언이 동시에 일어난다
 
함수 정의 definition
	반환타입 함수명( 파라미터1선언, 파라미터2선언, .. ){
		. . .
		return 어쩌구;
	} 

함수 호출
	걍 함수(arg1, arg2 .. ); 함 된다.






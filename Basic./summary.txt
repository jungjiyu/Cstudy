<기본 구성>

	: #define CRT_SECURE_NO_WARNINGS >> visual studio 상에서 보안상의 이유로 경고를 발생시키는 scanf, strcpy 등을 사용할 수 있게 함. 
	: #include <stdio.h>  >> printf 와 같은 함수를 사용 가능하게 함
		: 해석
			: stdio == STaandard Input Output
			: h == 파일의 확장자 . 헤더 파일
		



#include <stdio.h>
#define CRT_SECURE_NO_WARNINGS

int main() {


	return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------------------
<변수>


리터럴
	: 기본적으로 정수값은 int 형값
		: long 형은 뒤에 L 따로 붙임

	: 기본적으로 실수값은 double 형값
		: float 형은 뒤에 f 따로 붙임

	: 문자열상수
		:프로그래밍 코드 자체의 문자열상수만 문자열 상수다
			: 그러니까 gets() 나 scanf() 로 받은게 문자열상수는 아니다. 
				: 걍 일련의 데이터 이므로 직접 공간 확보를 한 후에(배열을 만들든 동적할당을 하든) 써야한다	
					:
					char *p;
					gets(p); 이런식으로하면 오류나지만 
	
					char *p = (char*)malloc(80); 
				 	gets(p); 처럼 하면 오류 안난다. (공간을 확보하고 써야된다.)


		: 문자열상수는 끝에 NULL문자 추가된 형태로 읽기전용 메모리영역에 char배열 형태로 따로 저장된다			: 문자열상수==  char 배열명 >> 주로 char 형 포인터에 할당해 사용한다
			1. char 포인터에 대입하여 사용가능
				:ex) char *p = "apple" ;
				: 물론 포인터 연산을 통한 인덱스변 접근도 가능
					ex) printf("%c",*("apple"+4)); // 결과 == 'e'

				: 문자열은 수정할 수 없다. 읽기전용메모리에 있으니까. 

			2. 형식지정자를 %c, %s, %p 등등 사용가능
					ex) printf("%p","apple");
					ex) printf("%c",*"apple"); //a출력

			3. 인덱스별 접근이 가능
				ex) printf("%c","apple"[2]); // 결과 == 'p'

	: 같은 문자열 상수의 경우 하나만 저장되고 , 공유된다. 




아스키코드:128개의 문자를 0~127 의 정수에 매치시켜놓은 것
	: 문자상수는 정수처럼 다룰 수 있기에 연속된 조건문 부분에서 정수다루듯이 다룰 수 있어 사용이 편리하다
	: 아스키코드를 일일이 외울 필요는 없지만 알고있어야할 특징:
		1. 연속된 알파벳,숫자는 연속된 아스키코드값을 가진다
			:숫자는 '0'~'9' 까지만 있다 --> 20 을 입력해도 '2' , '0' 따로 받는거다 
		2. 소문자가 대문자보다 아스키코드값이 크다
		3. 제어문자(이스케이프문자) 도 아스키코드값을 가진다


		
문자관련함수: getchar(), putchar()
	: 굳이 쓰는 이유) scanf 나 printf 는 문자 뿐 아니라 사이즈가 더 큰 정수까지 입력,출력하는 기능이 포함되있어
	문자만 입력하는 함수에 비해 크기가 큰데 문자 전용입출력함수를 사용하면 더 효율적 
	
	getchar();
		:원형) int getchar(void);
			: 반환형이 int 인 만큼 int 형 변수로 받는게 유리하다 
				: scanf에서 이러라는게 아니라 getchar() 쓸때를 말하는거다
				 
			:참고로 반환형이 char 이 아니라 int 형인 이유 
				: ctrl+z 는 입력을 종료한다는 건데 이게 -1 의 값을 가진다 
				: 데이터를 다른 자료형의 변수에 할당할 때 
				받을 변수의 사이즈 만큼 잘라서 받는데(뒷부분부터) 이때 잘라서 받을 데이터의 가장 앞비트는 유지한채 받게 된다. 
				그럼 int 로는 00000000000000000000000011111111 인 +255 는 char 변수의 형태로 할당될때 11111111 이 되므로 
				결론적으로는 -1 이 되버리고 만다. 따라서 이를 구분하기 위해서는 int 형 변수의 형태로 반환해야되고, int 형 변수로 할당받아야된다. 
					: 물론 키보드로만 입력받는다고 하면 0~127 까지의 숫자만 할당되겠지만 입력경로가 파일이 되는 경우 반환값이 255가 가능해진다 
					: 참고로 unsinged 자료형이었던 데이터를 다른 자료형의 변수로 받는다고 할떄 이때는 할당받을 데이터의 젤 앞비트값이 뭐였든지간에 무조건 0으로(+로) 들어간다 
			: 문자단위로 받은걸 문자배열에 저장해서 문자열로 사용하려할때 직접 끝에 '\0' 달아줘야되는거 주의
				: 근데 굳이 이러지 않고 싶으면 처음부터 {} 로 걍 초기화 해주면 기본적으로 모든 요소가 '\0'으로 초기화되서 따로 처리안해줘도 됨 
				: 보통 문자연속으로 입력할때 쓰인 i 로 끝 인덱스 캐치하여 마지막 인덱스 알아냄  
					int c,i=0; // 문자를 받는건데도 int 로 받는것은 getchar() 이 255 을 반환할 수도 있으니까 -1 처리되지 않게 하는것  
					c = getchar();
					while((c!='\n')&&(i<size-1)){ //(c!='\n') 써준거는 꼭 size꽉채워 다 입력 안받을 수 있으니까 . 
						str[i] = c;
						c= getchar(); 
						i++;
					} 
					str[i] = '\0'; // i == size-1 == 젤 끝 인덱스 .  
	putchar();
		:원형) int putchar(int);
			:반환형이 int인 이유는 출력과정에서 오류 발생시 -1을 반환하기 때문
			:엔터없이 출력한다 

		
대문자-> 소문자로 쉽게 바꾸는 법: 
	: 대문자의 아스키코드값이 소문자의 아스키코드값보다 작은 것을 고려하여 'a' - 'A' 한 값을 해당 소문자에 더한다
		ex)
		char c=z;
		printf("%c의 대문자: %c",c , c+('a'-'A') );

		: 이와 같은 원리로 소문자 -> 대문자로 바꾸기 위해서는 'A' - 'a' 한 값을 해당 대문자에 더하면 되는 것을 알 수 있따
*/




NULL 과 '\0'
	: NULL >>null 값. 아무것도 안가리킬떄의 참조값
	: '\0' >> null 문자. 문장의 끝에 붙임	
		: 이건 화이트 스페이스랑 다른거임 주의


이스케이프문자
	: \n == 엔터
	: \ 찐으로 쓰고 싶음 \\ 쓴다


 자료형 과 형식지정자
	정수형 <<사실 정수형의 경우 unsigned  도 가능	
		char , %c
			: 1바이트!!! . 아스키코드만
			: char 에도 음수 저장가능함 주의
			
				
		int , %d
			: 4바이트
		long , %ld
			: 4바이트
		long long , %lld  
			: 8 바이트

	실수형 
		float , %f
			:4바이트
		double, %lf
			: 8바이트

	기타
		%s:
			1. scanf() 로 입력받을때
				:  \n "전"까지 단어 단위로 받고, 그 뒤에 자동으로 '\0'을 더한 문자열을 반환한다  
					: 결국 '\n' 는 버퍼에 남는거 주의
					ex)
					char str[500];
					scanf("%s",str);scanf("%s",str); 했는데 'apple jam 엔터'하면 "apple\0" , "jam\0" 이 한꺼번에 저장된다.  (\n 이 수거되지 않고 있다)
			
			 
			2. printf() 로 출력할때 
				: 포인터 연산방식으로 작동한다. '\0' 이전의 내용까지 출력한다 
				: %s를 사용하는 원리
					:일단 기본적으로 char형 배열명을 대상으로 사용하고, 포인터 연산을 사용하여 NULL문자이전까지의 문자값을 출력한다.
						ex)
						char *p = "north";
						whlie(*p !=NULL){
							printf("%c",*(p++)); // p도 포인터이므로 포인터연산을 통하여 다음요소의 주소를 가지게할 수 있다.
						}


		%p >> 포인터에 저장된 주소 출력

유명한형변환
	: 자동형변환 << 대부분 더 커지는 쪽으로 변환. 데이터 손실을 최소화
		1. 정수의 승격	
			 정수끼리의 연산 >> 각 피연산자가 int 로 승격
		2. 정수가 실수화
			정수피연산자와 실수 피연산자로 연산 >> 정수피연산자가 실수화

		3. 할당에서의 자동형변환
			: 큰쪽애서 작은 쪽으로, 작은 쪽에서 큰쪽으로 둘 다 일어난다
 
	: 강제형변환 
		1.  정수를 실수화
			: 정수/정수 연산으로 소수점 까지 구하고 싶을때 

------------------------------------------------------------------------------------------------------------------------------------------------------
<출력>

printf("형식지정자짬뽕문장", 변수);

------------------------------------------------------------------------------------------------------------------------------------------------------

<입력: scanf 와 형식지정자 , 기타 문자 && 문자열입력함수>

scanf
	: https://namoo-gamedev.tistory.com/9
	: 키보드로 입력한 값은 버퍼에 저장되있다가 입력이 종료되면 버퍼에서 해당 데이터를 scanf 함수가 읽어오는거다.
		: 엔터를 기준으로 입력의 종료를 받아들인다. 입력의 종료시 scanf 함수는 버퍼에서 값을 읽어는오는데, 주어진 형식지정자에 대응하는 데이터만 get 해오고, 중간 중간의 화이트 스페이스는 구분자로 쓴다
			: 화이트 스페이스 이외의 구분자를 쓰고 싶으면 형식지정자들 사이에 , 나 # 같은걸 명시한다.
				

scanf와 형식지정자
	: 형식지정자는 scanf 에서는 명확히 지켜야하지만, printf 에선 꼭 지킬 필욘 없음
	: % 문자를 문자료 쓰고 싶음 %% 로 쓴다.
	: 화이트 스페이스
		: 형식지정자들 중 %c 만이 버퍼 상에서 화이트 스페이스를 수거할 수 있다.
			: 화이트 스페이스도 문자의 일종이기에 %c 가 받을 수 있는거다
			: %s 도 수거는 못한다
		   ****: 주의 ) %c 도 입력 받을때 엔터를 남긴다

		: %c , %s 를 포함하여 scanf 로 데이터를 입력받으면 뒤에 모두 엔터를 남긴다..
 			: 그렇다고 입력받는 과정에서 입력한 화이트 스페이스를 모두 남긴다는건 아니다
				: get 해야하는 데이터를 얻기 "전"까지 입력된 화이트 스페이스는 단순 구분자의 용도로 쓰이는거라 따로 남기지 않고 그냥 알아서 버려지는거고, 마지막에 입력 종룔 의미하는 엔터만 남는다
			: %s 의 경우 엔터'전' 까지만 scanf 가 읽어들이고, 뒤에 '\0'을 추가해주는거지, \n까지 수거한 후 그걸 \0 으로 바꿔주는게 아니다
				: 그건 scanf ( ) 가 아닌 gets(  ) 의 작동방식이다
			: %c 의 활동에 영향을 줄 수 있어 이후 별도 처리가 필요
				sol1 >> 입력 받고 나서 별도로 getChar( ) 이나 scanf("%c", &c); 쓴다
				sol2 >> 걍 이후에 %c 를 입력받아야하는 상황일때 앞에 스페이스바 입력하고 쓴다
					: 이렇게 하면 %c를 입력받을때도 화이트 스페이스를 무시하겠단 소리가 되서 , 버퍼에 화이트 스페이스가 남아있어도 그냥 무시한다


문자 입력전용 함수 int getchar( ) 
	: 주의 >> int 형 변수로 반환 값을 받아야한다
		: 파일의 끝이나 오류를 나타내는 값으로 -1 이 반환될 때도 있어서 그렇다

문자 출력전용 함수 putchar( int n ) 
	: 걍 putchar(변수); 이런식으로 씀 된다

문장 입력 함수 gets(char배열명); 
	:  scanf("%s") 보다 더 센스있게 \n 까지 읽어들이고, 그걸 \0 으로 바꾸는 방식으로 반환하기 떄문에 입력받고 나서도 버퍼가 깔끔하다
	: 얘로도 버퍼 상의 \n 을 치울수가 있다
	: string.h 포함 후에 사용필요

문장 출력 함수 puts(char배열명);
	: string.h 포함 후 사용 필요
------------------------------------------------------------------------------------------------------------------------------------------------------

문자열관련함수: string.h 포함 후에 사용필요 (scanf 뺴고)
	
	puts(char배열명); : 엔터까지 포함하여 문자열을 출력





<함수 사용>




/*
포인터 = 다른변수의 메모리 주소를 저장하는 '변수'
	: 선언
		: 자료형 * 포인터명;
			: 선언할때 쓰이는 * 은 간접참조연산자가 아닌 그냥 일반적인 변수와 포인터 변수의 선언을 구분하기 위한 기호
			: 가리킬변수의자료형== 포인터명 앞에 간접참조연산자 하나만 남기고 남은 형태
			: 포인터의 자료형 == 포인터명 앞 전체부분
				ex) int **b ; // int * == 가리킬변수의 자료형 , int ** == 포인터의 자료형
			: 동시선언가능
				: 시선언시 (타변수자료형 *) 한번만 해선 안되고 각각 * 해줘야됨
					ex) int *a, *b;

		: const로 선언 가능한데 그 뜻이 여러갤 가리킬 수 없단 소리가 아니라 그 가리틴 대상에 참조하여 변경불가하단 뜻이다

	: 초기화
		:변수의 주소나 동적할당하여 주소값으로 초기화한다.
		:반드시 초기화 한 이후에 활용가능하다.
			:동적할당으로 초기화된 포인터의 경우 자바에서의 배열생성과 매우 비슷하다.
				:ex) char *p = (char*)malloc(80); 에서 
					:char *p 부분은 레퍼런스 변수 선언
					(char*)malloc(80) 부분은 배열선언. 즉 실질적으로 데이터가 저장될 공간 확보. (포인터의 공간을 확보해주는게 아니다)
			 
			:이미 사용되고있는 메모리 영역을 침범가능하기 때문
		
	: 포인터의 크기 == 타변수 주소의 크기
		: 포인터들끼리 자료형이 다르더라도 포인터의 크기가 같다
			:포인터들끼리 크기가 같은데도 가리킬변수의 자료형을 명시하며 선언하는 이유는 참조단위를 결정하기 위함이다.
				:즉, 포인터연산을 해야되기때문이다
			:지정된 자료형의 변수만 가리켜야된다.
				: 만약 다른 자료형의 포인터를 대입한 경우
				포인터가 다른 자료형의 변수의 주소를 저장하는것까진 문제가 없는데(포인터변수의 사이즈가 같음)
				참조를 하는 스케일이 달라지므로 활용하는데 문제가 생긴다(포인터연산의 스케일이 다름).
			:변수의 크기와 마찬가지로 포인터의 크기도 sizeof() 을 통해 알 수 있다

배열과 포인터
	:주소가 정수값이긴 해도 일반적인 정수와 다르게 다루어진다.
		:포인터 연산이 가능한 이유이다.
		:주소 + 정수 == 주소 +  (정수*변수크기)
		:ex)
			int a = 10;
			int *p = a;
			printf("걍p: %d , p+1 = %d",p,(p+1));

	: '포인터명 == 배열명 == 배열의 0번째요소의 주소 '
	로 배열명과 포인터명 둘다 주소값이긴 해도 배열명은 상수이기에 변경이 불가하고
	포인터명은 주소를 저장하는 변수이기에 변경이 가능하다.
		:ex)
		int a[]={1,2,3};
		int *p=a;
		int i;

		for(i=0;i<3;i++){
		printf("%d",*(p++)); // p값은 변경됨
		}

		for(i=0;i<3;i++){
		printf("%d",*(a+i)); // a값은 유지됨
		}

	: (같은 자료형의) 포인터끼리 뺼셈도 가능하다
		: 포인터 - 포인터 == (두 포인터 주소값 차) / 자료형 크기 ==	몇 칸 이동하면 상대 포인터 위치로 가는지
			: a +2 == b 라고(a에서 2칸 더간게 b) 했을때 b-2 == a 되는거니까 (b에서 2칸 전으로 간게 a)

	: 배열을 인수로 받을떄 포인터를 매개변수로 하는 이유
		: 모든 요소를 넘기지 않아도 포인터 연산을 통하여 모든 요소에 접근이 가능하니까

	: 함수에서 인수로 배열을 받고 그 사이즈를 사용해야할 일이 있으면 매개변수 부분에서 사이즈를 따로 받아둔다
		: 아무리 포인터가 배열을 가리키는 경우라해도 sizeof 연산자를 쓰면 본인 포인터의 사이즈가 나오는거라
		요소의 개수를 구할 수 없다
			: 그렇다고 인수부분에서도 sizeof 를 못쓰는거 아니다
			원본이 있는 영역에서 그 배열명은 배열명으로썽의 ㅇ역할을 하기 때문에 sizeof()을 통해 정상적으로 사이즈를 구할 수 ㅇ있다.
				: ex)
				void ex(int * array,int n){
					int i;
					for(i=0;i<n;i++){ // n 없이 ex 함수 내에서 (sizeof(array)/sizeof(array[0])) 해봤자 소용없는거다
					printf("%d",array[i]);
					}
				}
				int main(void){
				int a[] ={1,2,3,4,5};
				ex(a, (sizeof(a)/sizeof(a[0]))); // 함수의 인수에서 sizeof 쓰는 것은 문제 없다
				return 0;
				}


	: 참고로 c언어에서는 배열형으로 매개변수를 설정할 수 있는데 컴파일러에 의하여 자동으로 포인터로 변환시키고 실행한다
		:따라서 매개변수 자리에서 선언된 배열의 사이즈는 무의미하고 아예사이즈를 지정하지 않아도 된다.
			ex) void func(int *array[]); // [] 안에 아예 아무것도 안써도 된다.
		:배열의 형태로 매개변수로 선언해도 포인터 취급받는거니까 어떻게 해도 함수 내부에서 sizeof 통해 개수를 구할 방법이 없으므로
		무슨 일이 있더라도 사이즈는 매개변수로 따로 받아야된다.(쓸ㅇ일이 있다면)
		:그냥 배열ㅇ을 인수로 할꺼면 포인터 써ㄱ라 굳이 배열로 받지말고 ㅁ


*/

/*






*/
/*


/*
버퍼를 사용하는 입력함수: scanf() , getchar() 
	버퍼: 데이터 보관 역할
		: 운영체제가(프로그램에서 직접할당이 아님) 자동으로 할당하는 메모리의 저장공간
		:키보드로 입력한 데이터는 일단 버퍼에 저장된 후 scanf같은 함숭에 의해 변수에 입력됨
	: 키보드로 입력한 데이터는 엔터를 눌러야 버퍼에 저장되고, 이때 사용된 개행문자도 함께 저장됨
	: scanf() 도 값을 반환할 수 있다: ctrl+z 누르고 엔터쳐서 버퍼로 넘기면 입력받길 종료한다는 의미를 가진 
	-1의 int 형정수를 반환한다  
		: -1 은 EOF 란 표현으로 대체 가능하다.(end of file 이란 의미로 stdio.h에 정의되어있음) 
		: -1을 반환한다고 해서 자체적으로 진짜 종료시켜주진 않고 자체적으로 코드 써야됨
			ex)
			int r; char c; 
			while(1){
			r = scanf("%c",&c); 
			if(r==EOF)break;
			} 
	: 문자 입력받을 때 뿐 아니라 숫자로써 숫자를 입력할때도 아스키코드화 한뒤에 형식지정자의 형태에 맞춰 연산하여 변수에 저장하는 거라고 한다
			ex) scanf("%d",&i); // 20 입력하면 버퍼에 '2','0','\n' 저장되고 '2','0'의 아스키코드화가 이루어진 후 형식지정자체크후 연산 수행하여 저장시킨다. 
	
	 
*/

/*
포인터배열: 요소가 포인터인 배열
	:선언형식
		자료형 *배열명[요소개수];
			: 자료형 == 각 요소들이 가리킬 변수의 자료형
			: [] 안이 사이즈가 아니라 요소개수인 이유는 포인터는 크기가 다 같은데 1바이트로 커버가능해서
	: char *배열명[] , 즉 char포인터배열의 경우 char형 문자열상수로 초기화 가능하다
		:각 요소가 char포인터명 이기 때문에 문자열상수값인 char형배열의 주소로 초기화 가능하다
			ex) char *array[]={"apple","pie","yummy"};

	: 활용
		1. 문자열의 주소를 요소로함 -- 문자열을 실제로 배열공간에 저장하는건 아님
		2. 문자열의 사이즈에 맞추어 동적할당하고 실제로 문자열을 요소로함
			:약간 자바의 배열과 비슷.
			레퍼런스변수 선언단계 == char포인터배열선언단계
			배열선언단계 ==  동적할당단계

	: 문자열상수 관련 배열종류
			1. 포인터배열
				:문자열의 주소를 요소로함
				:문자열은 별도의 메모리공간에 보관됨

			2. 2차원배열
				: max 길이를 기준으로 열이 만들어지므로 메모리 낭비가 있는편
				: 문자열자체를 배열공간에 저장

	 tb continued

*/


/*

다중포인터: 포인터의 주소를 값으로 하는 변수
	:이중까지만 보통 쓴다. (삼중,사중... 도 가능)


	:선언형식
		자료형	**이중포인터명;
			: 일반적인 포인터는 자료형 * 포인터명; 선언
			뜻은 (자료형) *포인터명; 으로 (자료형)타입의 변수를 가리키는 포인터를 선언했다는거임.
			이중포인터의 뜻은 (자료형*) *이중포인터명 으로 (자료형*) 타입의 변수를 가리키는 포인터를 선언했다는 거임

			: 이중포인터의 자료형은 (자료형**) 취급하면됨
				:'선언시 변수 바로 앞 별하나' == 포인터선언관례 ,
				'선언시 변수 바로앞 별하나 제외 나머지 부분' ==  '가리키는 변수의 자료형' ,
				'포인터명 앞부분전체' == '포인터의 자료형'
	:초기화형식
		이중포인터명=&포인터명;
	: 헷갈정리
		: &주소 는 불가능해도 &포인터는 된다.
			: 포인터도 변수니까 저장되는 메모리가 있다
		:
		이중포인터명 == 단일포인터주소
		*이중포인터명 == 단일포인터값==단일포인터가참조하는변수주소
		**이중포인터명 == 변수값 == 단일포인터가참조하는변수의값

	:활용
		1. 포인터값을 바꿀때(포인터가 어떤 변수를 가리킬지를 바꿀때) 매개변수로 사용
			:다중포인터가 필요한게 단일포인터로는 포인터의값(가리킬주소값)을 변경하지 못하기 때문이다
			: 간접참조연산자를 써서 바꿔야 찐으로 블럭 외부에서도 바뀌는건데 단일로만은 불가하다.
				: 단일포인터 매개변수로는 변수값을 바꾸는게 최대이다
					: 블럭내부에서 다른 변수의 주소를 복사해봤자 그 포인터는 매개변수라서 밖에서 적용이 안된다.

			: 포인터자체의 주소를 변경하겠단얘기가 아니라 포인터가 어떤 변수를 가리킬지를 변경하겠단 말이다
			ex)
			void change(int *a,int *b){
				*a = 10; //해당주소의 변수값을 수정할 순 있다
				a=b;//소용이 없는게 블럭 내부에서 당장은 주소값이 복사될지라도 밖에선 복사된게 아니다. 블럭내부의 포인터값이 바뀐것일뿐. 참조연산자가 있어야 찐 수정된거임.
			}

			void change(int **a , int **b){
				**a =10; //해당주소의 변수값 수정도 가능
				*a=*b; //주소값을 전역스케일로 변경가능

			}
			ex) 이중포인터를 사용하여 문자열 2개 swap <-- 개천재인게 swap 에서 tmp 역할얘를 배열로 만들어서 strcpy한게 아니라 그냥 포인터형으로 선언햇서
			첫번째 요소의 주소만 가져와서 포인터의 주소값만 바꿔준것


		2. 포인터배열을 매개변수로 받는 함수
			배열명 == '0번째 요소의 주소' 이므로 배열명도 일종의 포인터라고 할 수 있다(변경이 불가한 것 뿐)
			따라서 포인터배열명 == '0번째 요소의 주소' == '포인터의주소' == '이중포인터명'


*/
/*


동적할당은 언제 사용할까:
	:자바와 다르게 정방형배열만 가능하다(모든 열의 사이즈가 같아야된다) ---> 각 행에서 낭비되는 메모리가 존재
	:경우
		:1. 동적할당을 사용한 문자열 처리
			: 임시적으로 넉넉한 문자열배열에 문자열 받아두고 strlen로 사이즈 get 해 malloc로 동적할당하고 strcpy 로 복사해 저장
			: malloc()의 인수로 들어갈 사이즈==  ' strlen(문자열) + 1'
				: strlen() 의 리턴값은 NULL문자 제외임을 주의



동적할당: 실행시점에 메모리 공간을 할당하는 것
	: 변수의 선언으로 메모리공간을 할당하는 것은 프로그램이 실행할때 이루어진다.
	: 동적할당은 가변메모리를 가진 배열이라고 보면된다.
	: 포인터의 초기화값으로 쓰여 포인터가 레퍼런스변수역할을 하게 한다.
		: 그러니까 포인터생성-->포인터가가리킬메모리공간확보-->포인터를 통한 메모리공간참조
	: malloc , free
		: stdlib.h 헤더파일에 포함되어있다
		: malloc() : 메모리를 동적으로 할당
			: void* malloc(unsinged int size); 가 함수의 원형이다
				: 반환형이 void* 형 ---> 포인터형태로 사용될 수 있는 아이란 뜻. 사용전 용도에 맞는 포인터로 형변환해 사용하란거
				: 만약에 정상적으로 동적할당이 이루어지지 않으면 NULL포인터를 반환한다.
					:NULL 포인터: 0번지
						: NULL 로 표기 되고 전처리 단계에서 0으로 바뀌므로 정수 0과 같으나 그냥 NULL으로 명시해서 써라

			: 사용형식 == 포인터로 형변환한 것을 초기화하여 사용한다
				(자료형*)malloc(sizeof(자료형));

					:ex) int* p = (int *)malloc(n*sizeof(int));
					:malloc() 괄호 안에는 바이트단위의 사이즈가 들어가야되는건데 컴파일러마다 크기가 다를 수 있으니 sizeof 써주는거다
					:n은 요소의 개수를 의미한다
						:같은 자료형의 변수들을 하나하나 동적할당해주는것보다 배열처럼 한번에 동적할당하는게 편하기때문
							:포인터를 마치 배열처럼 사용하면 된다.
								: 포인터명[n] = 배열명[n] , 포인터명+ n = &(배열명[n]) 이므로
									: scanf("형식지정자",&포인터명[n]);   // 배열명 자체가 아닌 요소 단위로 접근시 & 사용하는거 잊지x
									: printf("형식지정자",포인터명[n]); // 요소단위로 사용시 * 필요없음 주의
									: free(포인터배열명[n]) //  포인터배열의 요소 단위로 메모리 반환

					:포인터로 형변환해주는 이유는 malloc() 반환형이 void* 로 자료형을 따로 지정해주어야하는 포인터형이라서.

			: 동적할당에 실패하면 NULL 값을 반환한다
				:동적할당 시도 코드 다음에 반드시 NULL 값인지 체크햊줘야된다
					:실패시 exit(1) 을 사용한다
						:exit() == 프로그램을 즉시 종료시킨다.
							:예외상황이 발생해 종료시킬때 인수를 1로 주로함.

					:ex)
					int* p = (int *)malloc(sizeof(int));
					if(*p==NULL){
					printf("something is wrong here");
					exit(1);
					}

			: 동적할당한 저장공간을 다 사용한 이후에는 직접 free()써서 이후에 동적할당할 공간ㄴ을 많이 확보해두어야됨

		free(): 메모리 반환
			:형식
				free(동적할당된 포인터명);

			:malloc 쓰든 calloc쓰든 공통으로 쓴다
				: 메모리공간 확보를 위하여

	기타 동적할당시 유용한 함수
		:다른 얘들도 stdlib.h 에 포함되어있다
		calloc(): 동적 할당하는데 요소를 모두 0으로 초기화시킬때 유리
			: 원형
				void * calloc(unsinged int 요소개수 , unsinged 요소하나크기);
					:malloc 와 마찬가지로 반환형이 void*형이라 사용전에 포인터형변환해줘야됨
					:malloc는 전체 사이즈를 바이트 단위로 한번에 다 적게했다면 calloc는 * 를 분리하여 요소의 개수를 더 명시하게 한 느낌

			: 형식: malloc 와 사용형식 같다. 다만 별도로 값 초기화 안해도 이미 초기화 되있다는게 차이점
				 (자료형 *)calloc(n,sizeof(자료형));
				 	:ex) int *array = (int*)calloc(5,sizeof(int));

		realloc(): 동적할당된 포인터의 기존 정보를 유지하면서 사이즈를 변형하고 싶을때 사용
			:포인터의 사이즈를 늘리는 것 뿐아니라 줄일 수도 있다.---> 줄이는 경우 뒷자리의 데이터들이 순차적으로 썰린다
			:포인터 자기자신을 변형하지 않고 자기자신을 변형한 형태를 다른 포인터의 초기화 값으로 할 수도 있다.
				: 그냥자기자신에 할당하지 않고 다른 포인터에 할당하면 되는거임

			:원형
				void * realloc(void* , unsinged int);
					: 매개변수가 void* 라는건 모든 타입의 포인터를 매개변수로 할 수 있단 말이다

			:형식
				포인터명2 = (자료형*)realloc(포인터명1,변경사이즈);
					:포인터명2 == 포인터명1 이면 기존 포인터의 사이즈가 변경되고 , 기존포인터의 메모리가 재할당되는것
						: 포인터의 주소가 재할당된다면(썰리는게 아니라 메모리가 늘어나 메모리의 위치가 바뀐다면)
						 이전 메모리는 free() 같은거 없이도 자동삭제된다 <--- 가비지 처리이다. 아무도 참조하고 있는 얘가 없으니까
					:포인터명2 != 포인터명1 이면 기존 포인터는 유지되고 다른 포인터가 기존포인터의 정보를 가지며 초기화되는것
					:ex)
						int *p = (int*)malloc(5*sizeof(int));
				 		p= (int*)realloc(p,10*sizeof(int)); // 기존 포인터의 데이터를 유지하며 '사이즈' 변경
			 			int *z = (int*)realloc(p,11*sizeof(int)); // 기존포인터의 데이터를 새로운 포인터로 복사함

	*/

/*

구조체: 사용자정의자료형  <---typedef는 자료형명 재정의 이다. 사용자정의자료형이라고하지 않는다
	: 다양한 자료형의 요소 즉 멤버를 취할 수 있다
	: 구조체선언
		struct 구조체명{멤버선언};
			: 함수 내부에서 정의되면 그 함수에서만 쓸 수 있다
			: 선언했다고 메모리공간 차지하는거 아니다
			: 구조체도 함수와 마찬가지로 원형선언하면 사용시점보다 더 뒤에서 선언되어도 오류가나지 않는다
			: 멤버는 배열, 포인터 , 다른 구조체 까지 다 가능
		 		: 구조체를 멤버로 하는 경우 상식적으로 . 사용해서 쓰면 된다
				 	ex)
					 struct student_profile{
					 	int age;
					 	double grade;
					 };

					 struct person{
					 	struct student_profile student;
					 	char name[100];
					 };

		 			int main(void){
					 	struct person jiyu;
					 	jiyu.student.age = 19;
					 	jiyu.student.grade = 4.5;
					 	strcpy(jiyu.name ,"jiyu");
					 }

	: 구조체변수선언
		struct 구조체명 변수명;
			: struct 구조체명 == 사용자정의자료형
			: 변수를 선ㄴ언하고 나서야 비로소 메모리 할당됨
				: 구조체변수 크기 == ' 각 멤버의 크기의 총합 +알파 '
					:딱 각 멤버의 크기의 총합이 아닌 이유는 '패딩바이트'가 존재하기때문.
					즉 가장큰 멤버의 크기가 직사각형의 한변이 된다
						:패딩바이트를 최소화하기 위해선는 멤버선언순서가 중요하다---최대한 빈칸없이 만들어라
						:패딩바이트) 바이트 얼라인먼트 를 위해 쓰이는 바이트
							:바이트얼라인먼트) 메모리를 가지런하게 정렬하는것. 즉 직사각형꼴로 만드는것

			: 여러개의 구조체변수를 한번에 선언할 수 있고 심지어 중괄호를 이용한 초기화까지 가능하다
				ex)
					struct nojam jiyu={"jiyu",10}, yuha={"yuha",12} ;

	: 초기화
		1. 멤버단위
			: 구조체명.멤버명;
		2. 통째로
			:{} 사용
		3. 이미 초기화된 다른 구조체변수를 대입 --> 같은 타입이어야됨
			:ex)
			struct fuck a={1,"uiui"};
			struct fuck b= a;

	: 참고로 구조체선언, 구조체변수선언, 구조체변수초기화 ㄹ를 한방에 진행 가능
		ex)
		struct animal{
			int age;
			char *name;
		}rabbit = {16,"rabbit"};

	: 구조체와 함수
		: 사용자정의타입은 매개변수 뿐 아니라 반환형도 될 수 있다
			: 구조체변수를 매개변수로
				:구조체변수의 멤버값을 단순히 꺼내쓰고 싶을때 사용한다.
					:구조체변수가 포인터는 아니므로 함수 내부에서 수정한다고 바뀌는게 아니다
						: 만약에 구조체변수의 값을 함수 내부서 변형시키고 싶은거면 구조체포인터를 매개변수로 해야된다.

			: 구조체를 반환형으로
				: (함수 내부에서 사용된 구조체변수명은 리턴되지 않지만) 멤버들값을 반환된다.


	: 구조체와 포인터
		: 구조체를 가리키는 포인터를 만들고 싶으면 구조체형으로 정의하면 된다.
			:주로 함수에서 구조체변수값을 직접변경하고 싶을 때 매개변수로써 잘 사용됨
				ex)
				void change(struct chubby *x){
					x->kg = 100;
					x->age = 18;
				}

		:구조체포인터 선언 형식
				struct 구조체명 *포인터명;

		: 구조체변수의 주소== 멤버전체의 주소
			: *포인터명 == 구조체변수명
				: 멤버접근연산자의 우선순위가 간접참조연산자보다 높으므로 포인터를 통하여 멤버에 접근할때 괄호 꼭 써라.
					:ex)
						struct dummy hojun={39,"hojun"};
						struct dummy * p = &hojun;
						(*p).age = 88;

		:간접멤버접근연산자
			:포인터로 멤버에 접근할때 쓰인다
			:형식
				포인터명 ->멤버명 ; // (*포인터명).멤버명 이랑 같은 뜻
					:ex)
						struct dummy hojun={39,"hojun"};
						struct dummy * p = &hojun;
						p-> age = 88; //==(*p).age = 88;

			:포인터연산적용하면서도 사용가능
				ex)

				int i;
				for(i=0 ; i<size;i++){
					printf("%lf %s %lf", (p+i)->score , (p+i)->name , (p+i)->gpa);
				}


			:여러개 한번에 사용가능
				ex1) head->next->value // == (*((*head).next)).value
					: 구조체포인터 멤버를 가질때 그 멤버가 가리키고 있는 구조체를 ->를 이용해서 접근한것

				ex2) a->num = b->num = 10; // (*a).num = (*b).num = 10;

		:구조체배열
			:같은 구조체타입의 변수가 많이 필요하다면 사용
			: 한번에 초기화 할땐 중괄호를 두번 씀 됨
				ex) struct dummy array[]={{39,"hojun"},{29,"jojun"},{19,"uojun"}};

		:자기참조구조체
			:자기타입의 포인터를 멤버로 하는것.
			:관련된 데이터를 하나로 묶어 관리하기 위해 사용
			:연결리스트(링크드리스트)에 사용됨
typedef: 자료형이름제정의
	:형식
		1.선언이후에 적용
			 typedef 기존자료형명 새로운자료형명;

				 :되도록이면 2번 방법써라 . 1번 방법은 기존자료형명도 써야되는 경우에 써라.

		2. 선언과 동시에 적용
			typedef struct{

			}새로운자료형명;

				: 구조체명을 써도 되긴 되는데 굳이? 어차피 새로운 자료형명으로만 쓸거면서
*/
